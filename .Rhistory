library(parallel)
library(doParallel)
library(foreach)
YRS = 10
SIMS = 10
par(mfrow=c(1,1))
list.to.df = function(l) {
return(data.frame(matrix(unlist(l), nrow=length(l), byrow=T)))
}
### Extracts JUST the resource positions for each element of a gmse sims list,
###  i.e. returns a list of lists, of resource positions per time step per sim:
get_res_pos = function(gmse_sims_list) {
lapply(gmse_sims_list, function(x) { lapply(x$resource, function(y) y[,c(1,5,6)]) } )
}
OUT = list()
#PARS = expand.grid(STAKEHOLDERS = 12, USR_YLD_BUDGET = seq(0,0.45,0.05), OWNERSHIP_VAR = seq(0.1,1,0.1))
PARS = expand.grid(STAKEHOLDERS = 12, USR_YLD_BUDGET = 0.1, OWNERSHIP_VAR = c(0,0.25))
for(k in 1:nrow(PARS)) {
cat(sprintf("\n"), file = "foreach_log.txt", append = TRUE)
cl = makeCluster(6,outfile="foreach_log.txt")
registerDoParallel(cl = cl)
cat(sprintf("\n%s - parameter set %d / %s.. \n\n", Sys.time(), k, nrow(PARS)), file = "foreach_log.txt", append = TRUE)
cat(sprintf("\n%s - parameter set %d / %s..", Sys.time(), k, nrow(PARS)))
results <- foreach(i=1:SIMS, .export=c('gmse'), .packages=c('GMSE')) %dopar% {
gmse(time_max = YRS,
RESOURCE_ini = 1000,
consume_surv = 2,
consume_repr = 3,
times_feeding = 6,
remove_pr = 0.1,
land_ownership = TRUE,
scaring = TRUE,
tend_crops = TRUE,
tend_crop_yld = 0.2,
usr_yld_budget = PARS$USR_YLD_BUDGET[k],
stakeholders = PARS$STAKEHOLDERS[k],
user_budget = 1000,
ownership_var = PARS$OWNERSHIP_VAR[k],
plotting = FALSE)
}
### Get results summary:
res_summary = lapply(results, gmse_summary)
### Add resource positions to summary:
res_positions = get_res_pos(results)
for(z in 1:length(res_summary)) {
res_summary[[z]]$res_positions = res_positions[[z]]
}
rm(results, res_positions)
OUT[[k]] = res_summary
gc()
stopCluster(cl)
}
saveRDS(OUT, "OUT.Rds")
### GMSE sims in parallel
rm(list=ls())
library(GMSE)
library(parallel)
library(doParallel)
library(foreach)
YRS = 20
SIMS = 100
par(mfrow=c(1,1))
list.to.df = function(l) {
return(data.frame(matrix(unlist(l), nrow=length(l), byrow=T)))
}
### Extracts JUST the resource positions for each element of a gmse sims list,
###  i.e. returns a list of lists, of resource positions per time step per sim:
get_res_pos = function(gmse_sims_list) {
lapply(gmse_sims_list, function(x) { lapply(x$resource, function(y) y[,c(1,5,6)]) } )
}
OUT = list()
#PARS = expand.grid(STAKEHOLDERS = 12, USR_YLD_BUDGET = seq(0,0.45,0.05), OWNERSHIP_VAR = seq(0.1,1,0.1))
PARS = expand.grid(STAKEHOLDERS = 12, USR_YLD_BUDGET = 0.1, OWNERSHIP_VAR = c(0,0.25))
for(k in 1:nrow(PARS)) {
#cat(sprintf("\n"), file = "foreach_log.txt", append = TRUE)
cat(sprintf("\n%s - parameter set %d / %s.. \n\n", Sys.time(), k, nrow(PARS)), file = "foreach_log.txt", append = TRUE)
cat(sprintf("\n%s - parameter set %d / %s..", Sys.time(), k, nrow(PARS)))
cl = makeCluster(6,outfile="foreach_log.txt")
registerDoParallel(cl = cl)
results <- foreach(i=1:SIMS, .export=c('gmse'), .packages=c('GMSE')) %dopar% {
gmse(time_max = YRS,
RESOURCE_ini = 1000,
consume_surv = 2,
consume_repr = 3,
times_feeding = 6,
remove_pr = 0.1,
land_ownership = TRUE,
scaring = TRUE,
tend_crops = TRUE,
tend_crop_yld = 0.2,
usr_yld_budget = PARS$USR_YLD_BUDGET[k],
stakeholders = PARS$STAKEHOLDERS[k],
user_budget = 1000,
ownership_var = PARS$OWNERSHIP_VAR[k],
plotting = FALSE)
}
### Get results summary:
res_summary = lapply(results, gmse_summary)
### Add resource positions to summary:
res_positions = get_res_pos(results)
for(z in 1:length(res_summary)) {
res_summary[[z]]$res_positions = res_positions[[z]]
}
rm(results, res_positions)
OUT[[k]] = res_summary
gc()
stopCluster(cl)
}
saveRDS(OUT, "OUT.Rds")
17-11
OUT = read.RDS("OUT.Rds")
OUT = readRDS("OUT.Rds")
str(OUT)
OUT[[1]][[1]]$resources
OUT[[1]][[2]]$resources
OUT[[1]][[3]]$resources
OUT[[1]][[4]]$resources
### GMSE sims in parallel
rm(list=ls())
library(GMSE)
library(parallel)
library(doParallel)
library(foreach)
YRS = 20
SIMS = 100
par(mfrow=c(1,1))
list.to.df = function(l) {
return(data.frame(matrix(unlist(l), nrow=length(l), byrow=T)))
}
### Extracts JUST the resource positions for each element of a gmse sims list,
###  i.e. returns a list of lists, of resource positions per time step per sim:
get_res_pos = function(gmse_sims_list) {
lapply(gmse_sims_list, function(x) { lapply(x$resource, function(y) y[,c(1,5,6)]) } )
}
OUT = list()
#PARS = expand.grid(STAKEHOLDERS = 12, USR_YLD_BUDGET = seq(0,0.45,0.05), OWNERSHIP_VAR = seq(0.1,1,0.1))
PARS = expand.grid(STAKEHOLDERS = 12, USR_YLD_BUDGET = 0.1, OWNERSHIP_VAR = c(0,0.25))
k = 1
cat(sprintf("\n%s - parameter set %d / %s..", Sys.time(), k, nrow(PARS)))
cl = makeCluster(6,outfile="foreach_log.txt")
registerDoParallel(cl = cl)
results <- foreach(i=1:SIMS, .export=c('gmse'), .packages=c('GMSE')) %dopar% {
gmse(time_max = YRS,
RESOURCE_ini = 1000,
consume_surv = 2,
consume_repr = 3,
times_feeding = 6,
remove_pr = 0.1,
land_ownership = TRUE,
scaring = TRUE,
tend_crops = TRUE,
tend_crop_yld = 0.2,
usr_yld_budget = PARS$USR_YLD_BUDGET[k],
stakeholders = PARS$STAKEHOLDERS[k],
user_budget = 1000,
ownership_var = PARS$OWNERSHIP_VAR[k],
plotting = FALSE)
}
### Get results summary:
res_summary = lapply(results, gmse_summary)
### Add resource positions to summary:
res_positions = get_res_pos(results)
for(z in 1:length(res_summary)) {
res_summary[[z]]$res_positions = res_positions[[z]]
}
### Get results summary:
res_summary = list(data = lapply(results, gmse_summary))
### Add resource positions to summary:
res_positions = get_res_pos(results)
length(res_summary)
length(res_summary)$data
length(res_summary$data)
res_summary$data[[1]]
### Add resource positions to summary:
res_positions = get_res_pos(results)
for(z in 1:length(res_summary$data)) {
res_summary$data[[z]]$res_positions = res_positions[[z]]
}
results[[1]]
results[[1]]$paras
PARS = expand.grid(TIME_MAX = YRS,
RESOURCE_INI = 1000,
CONSUME_SURV = 2,
CONSUME_REPR = 3,
TIMES_FEEDING = 6,
REMOVE_PR = 0.1,
LAND_OWNERSHIP = TRUE,
SCARING = TRUE,
TEND_CROPS = TRUE,
TEND_CROP_YLD = 0.2,
USR_YLD_BUDGET = 0.1,
STAKEHOLDERS = 12,
USER_BUDGET = 1000,
OWNERSHIP_VAR = c(0,0.25)
)
PARS[1]
#PARS = expand.grid(STAKEHOLDERS = 12, USR_YLD_BUDGET = seq(0,0.45,0.05), OWNERSHIP_VAR = seq(0.1,1,0.1))
PARS = expand.grid(TIME_MAX = YRS,
RESOURCE_INI = 1000,
CONSUME_SURV = 2,
CONSUME_REPR = 3,
TIMES_FEEDING = 6,
REMOVE_PR = 0.1,
LAND_OWNERSHIP = TRUE,
SCARING = TRUE,
TEND_CROPS = TRUE,
TEND_CROP_YLD = 0.2,
USR_YLD_BUDGET = 0.1,
STAKEHOLDERS = 12,
USER_BUDGET = 1000,
OWNERSHIP_VAR = 0
)
PARS[1,]
nrow(PARS)
PARS[1]
PARS
k
PARS[k,]
as.list(PARS[k,])
list(PARS[k,])
PARS[k,]
t(PARS[k,])
as.list(t(PARS[k,]))
list(PARS[k,])
as.list(PARS[k,])
temp = as.list(PARS[k,])
temp[[1]]
temp[1]
temp
PARS[k,]
class(PARS[k,])
as.matrix(PARS[k,])
as.list(as.matrix(PARS[k,]))
### Get and save parameters with output list:
pars = as.list(as.matrix(PARS[k,]))
names(pars)
names(PARS)
names(pars) = names(PARS)
pars
res_summary$paras = pars
res_summary$paras
### GMSE sims in parallel
rm(list=ls())
library(GMSE)
library(parallel)
library(doParallel)
library(foreach)
YRS = 10
SIMS = 10
par(mfrow=c(1,1))
list.to.df = function(l) {
return(data.frame(matrix(unlist(l), nrow=length(l), byrow=T)))
}
### Extracts JUST the resource positions for each element of a gmse sims list,
###  i.e. returns a list of lists, of resource positions per time step per sim:
get_res_pos = function(gmse_sims_list) {
lapply(gmse_sims_list, function(x) { lapply(x$resource, function(y) y[,c(1,5,6)]) } )
}
OUT = list()
#PARS = expand.grid(STAKEHOLDERS = 12, USR_YLD_BUDGET = seq(0,0.45,0.05), OWNERSHIP_VAR = seq(0.1,1,0.1))
PARS = expand.grid(TIME_MAX = YRS,
RESOURCE_INI = 1000,
CONSUME_SURV = 2,
CONSUME_REPR = 3,
TIMES_FEEDING = 6,
REMOVE_PR = 0.1,
LAND_OWNERSHIP = TRUE,
SCARING = TRUE,
TEND_CROPS = TRUE,
TEND_CROP_YLD = 0.2,
USR_YLD_BUDGET = 0.1,
STAKEHOLDERS = 12,
USER_BUDGET = 1000,
OWNERSHIP_VAR = 0
)
for(k in 1:nrow(PARS)) {
#cat(sprintf("\n"), file = "foreach_log.txt", append = TRUE)
cat(sprintf("\n%s - parameter set %d / %s.. \n\n", Sys.time(), k, nrow(PARS)), file = "foreach_log.txt", append = TRUE)
cat(sprintf("\n%s - parameter set %d / %s..", Sys.time(), k, nrow(PARS)))
cl = makeCluster(6,outfile="foreach_log.txt")
registerDoParallel(cl = cl)
results <- foreach(i=1:SIMS, .export=c('gmse'), .packages=c('GMSE')) %dopar% {
gmse(time_max = PARS$TIME_MAX[k],
RESOURCE_ini = PARS$RESOURCE_INI[k],
consume_surv = PARS$CONSUME_SURV[k],
consume_repr = PARS$CONSUME_REPR[k],
times_feeding = PARS$TIMES_FEEDING[k],
remove_pr = PARS$REMOVE_PR[k],
land_ownership = PARS$LAND_OWNERSHIP[k],
scaring = PARS$SCARING[k],
tend_crops = PARS$TEND_CROPS[k],
tend_crop_yld = PARS$TEND_CROP_YLD[k],
usr_yld_budget = PARS$USR_YLD_BUDGET[k],
stakeholders = PARS$STAKEHOLDERS[k],
user_budget = PARS$USER_BUDGET[k],
ownership_var = PARS$OWNERSHIP_VAR[k],
plotting = FALSE)
}
### Get results summary:
res_summary = list(data = lapply(results, gmse_summary))
### Add resource positions to summary:
res_positions = get_res_pos(results)
for(z in 1:length(res_summary$data)) {
res_summary$data[[z]]$res_positions = res_positions[[z]]
}
### Get and save parameters with output list:
pars = as.list(as.matrix(PARS[k,]))
names(pars) = names(PARS)
res_summary$paras = pars
rm(results, res_positions)
OUT[[k]] = res_summary
gc()
stopCluster(cl)
}
saveRDS(OUT, "OUT.Rds")
OUT[[1]]$paras
### GMSE sims in parallel
rm(list=ls())
library(GMSE)
library(parallel)
library(doParallel)
library(foreach)
YRS = 10
SIMS = 10
par(mfrow=c(1,1))
list.to.df = function(l) {
return(data.frame(matrix(unlist(l), nrow=length(l), byrow=T)))
}
### Extracts JUST the resource positions for each element of a gmse sims list,
###  i.e. returns a list of lists, of resource positions per time step per sim:
get_res_pos = function(gmse_sims_list) {
lapply(gmse_sims_list, function(x) { lapply(x$resource, function(y) y[,c(1,5,6)]) } )
}
OUT = list()
#PARS = expand.grid(STAKEHOLDERS = 12, USR_YLD_BUDGET = seq(0,0.45,0.05), OWNERSHIP_VAR = seq(0.1,1,0.1))
PARS = expand.grid(TIME_MAX = YRS,
RESOURCE_INI = 1000,
CONSUME_SURV = 2,
CONSUME_REPR = 3,
TIMES_FEEDING = 6,
REMOVE_PR = 0.1,
LAND_OWNERSHIP = TRUE,
SCARING = TRUE,
TEND_CROPS = TRUE,
TEND_CROP_YLD = 0.2,
USR_YLD_BUDGET = 0.1,
STAKEHOLDERS = 12,
USER_BUDGET = 1000,
OWNERSHIP_VAR = c(0,0.1)
)
PARS
for(k in 1:nrow(PARS)) {
#cat(sprintf("\n"), file = "foreach_log.txt", append = TRUE)
cat(sprintf("\n%s - parameter set %d / %s.. \n\n", Sys.time(), k, nrow(PARS)), file = "foreach_log.txt", append = TRUE)
cat(sprintf("\n%s - parameter set %d / %s..", Sys.time(), k, nrow(PARS)))
cl = makeCluster(6,outfile="foreach_log.txt")
registerDoParallel(cl = cl)
results <- foreach(i=1:SIMS, .export=c('gmse'), .packages=c('GMSE')) %dopar% {
gmse(time_max = PARS$TIME_MAX[k],
RESOURCE_ini = PARS$RESOURCE_INI[k],
consume_surv = PARS$CONSUME_SURV[k],
consume_repr = PARS$CONSUME_REPR[k],
times_feeding = PARS$TIMES_FEEDING[k],
remove_pr = PARS$REMOVE_PR[k],
land_ownership = PARS$LAND_OWNERSHIP[k],
scaring = PARS$SCARING[k],
tend_crops = PARS$TEND_CROPS[k],
tend_crop_yld = PARS$TEND_CROP_YLD[k],
usr_yld_budget = PARS$USR_YLD_BUDGET[k],
stakeholders = PARS$STAKEHOLDERS[k],
user_budget = PARS$USER_BUDGET[k],
ownership_var = PARS$OWNERSHIP_VAR[k],
plotting = FALSE)
}
### Get results summary:
res_summary = list(data = lapply(results, gmse_summary))
### Add resource positions to summary:
res_positions = get_res_pos(results)
for(z in 1:length(res_summary$data)) {
res_summary$data[[z]]$res_positions = res_positions[[z]]
}
### Get and save parameters with output list:
pars = as.list(as.matrix(PARS[k,]))
names(pars) = names(PARS)
res_summary$paras = pars
rm(results, res_positions)
OUT[[k]] = res_summary
gc()
stopCluster(cl)
}
saveRDS(OUT, "OUT.Rds")
OUT[[1]]$paras
OUT[[2]]$paras
seq(0,0.9,0.1)
lenth(seq(0,0.9,0.1))
length(seq(0,0.9,0.1))
seq(0,0.5,0.1)
seq(0,0.5,0.05)
length(seq(0,0.5,0.05))
length(seq(0,0.45,0.05))
seq(0,0.45,0.05)
### GMSE sims in parallel
rm(list=ls())
library(GMSE)
library(parallel)
library(doParallel)
library(foreach)
YRS = 10
SIMS = 10
par(mfrow=c(1,1))
list.to.df = function(l) {
return(data.frame(matrix(unlist(l), nrow=length(l), byrow=T)))
}
### Extracts JUST the resource positions for each element of a gmse sims list,
###  i.e. returns a list of lists, of resource positions per time step per sim:
get_res_pos = function(gmse_sims_list) {
lapply(gmse_sims_list, function(x) { lapply(x$resource, function(y) y[,c(1,5,6)]) } )
}
OUT = list()
#PARS = expand.grid(STAKEHOLDERS = 12, USR_YLD_BUDGET = seq(0,0.45,0.05), OWNERSHIP_VAR = seq(0.1,1,0.1))
PARS = expand.grid(TIME_MAX = YRS,
RESOURCE_INI = 1000,
CONSUME_SURV = 2,
CONSUME_REPR = 3,
TIMES_FEEDING = 6,
REMOVE_PR = 0.1,
LAND_OWNERSHIP = TRUE,
SCARING = TRUE,
TEND_CROPS = TRUE,
TEND_CROP_YLD = 0.2,
USR_YLD_BUDGET = seq(0,0.45,0.05),
STAKEHOLDERS = 12,
USER_BUDGET = 1000,
OWNERSHIP_VAR = seq(0,0.9,0.1)
)
PARS
nrow(pars)
nrow(PARS)
### GMSE sims in parallel
rm(list=ls())
library(GMSE)
library(parallel)
library(doParallel)
library(foreach)
YRS = 20
SIMS = 100
par(mfrow=c(1,1))
list.to.df = function(l) {
return(data.frame(matrix(unlist(l), nrow=length(l), byrow=T)))
}
### Extracts JUST the resource positions for each element of a gmse sims list,
###  i.e. returns a list of lists, of resource positions per time step per sim:
get_res_pos = function(gmse_sims_list) {
lapply(gmse_sims_list, function(x) { lapply(x$resource, function(y) y[,c(1,5,6)]) } )
}
OUT = list()
#PARS = expand.grid(STAKEHOLDERS = 12, USR_YLD_BUDGET = seq(0,0.45,0.05), OWNERSHIP_VAR = seq(0.1,1,0.1))
PARS = expand.grid(TIME_MAX = YRS,
RESOURCE_INI = 1000,
CONSUME_SURV = 2,
CONSUME_REPR = 3,
TIMES_FEEDING = 6,
REMOVE_PR = 0.1,
LAND_OWNERSHIP = TRUE,
SCARING = TRUE,
TEND_CROPS = TRUE,
TEND_CROP_YLD = 0.2,
USR_YLD_BUDGET = seq(0,0.45,0.05),
STAKEHOLDERS = 12,
USER_BUDGET = 1000,
OWNERSHIP_VAR = seq(0,0.9,0.1)
)
for(k in 1:nrow(PARS)) {
#cat(sprintf("\n"), file = "foreach_log.txt", append = TRUE)
cat(sprintf("\n%s - parameter set %d / %s.. \n\n", Sys.time(), k, nrow(PARS)), file = "foreach_log.txt", append = TRUE)
cat(sprintf("\n%s - parameter set %d / %s..", Sys.time(), k, nrow(PARS)))
cl = makeCluster(6,outfile="foreach_log.txt")
registerDoParallel(cl = cl)
results <- foreach(i=1:SIMS, .export=c('gmse'), .packages=c('GMSE')) %dopar% {
gmse(time_max = PARS$TIME_MAX[k],
RESOURCE_ini = PARS$RESOURCE_INI[k],
consume_surv = PARS$CONSUME_SURV[k],
consume_repr = PARS$CONSUME_REPR[k],
times_feeding = PARS$TIMES_FEEDING[k],
remove_pr = PARS$REMOVE_PR[k],
land_ownership = PARS$LAND_OWNERSHIP[k],
scaring = PARS$SCARING[k],
tend_crops = PARS$TEND_CROPS[k],
tend_crop_yld = PARS$TEND_CROP_YLD[k],
usr_yld_budget = PARS$USR_YLD_BUDGET[k],
stakeholders = PARS$STAKEHOLDERS[k],
user_budget = PARS$USER_BUDGET[k],
ownership_var = PARS$OWNERSHIP_VAR[k],
plotting = FALSE)
}
### Get results summary:
res_summary = list(data = lapply(results, gmse_summary))
### Add resource positions to summary:
res_positions = get_res_pos(results)
for(z in 1:length(res_summary$data)) {
res_summary$data[[z]]$res_positions = res_positions[[z]]
}
### Get and save parameters with output list:
pars = as.list(as.matrix(PARS[k,]))
names(pars) = names(PARS)
res_summary$paras = pars
rm(results, res_positions)
OUT[[k]] = res_summary
gc()
stopCluster(cl)
}
saveRDS(OUT, "OUT.Rds")
